commit 5de7396ca3358faac3126ad965cae12070079286
Author: Albert Lee <trisk@omniti.com>
Date:   Thu Aug 6 13:25:20 2015 -0400

    zones implementation for SPL based on dataset namespace
    
    This introduces full implementations of crgetzone, crgetzoneid, and
    zone_dataset_visible. When loaded, the spl module will register
    with the dataset namespace and create zone objects for each namespace.
    
    Signed-off-by: Albert Lee <trisk@omniti.com>

diff --git a/include/sys/sysmacros.h b/include/sys/sysmacros.h
index 4dc7cd8..9937412 100644
--- a/include/sys/sysmacros.h
+++ b/include/sys/sysmacros.h
@@ -30,7 +30,6 @@
 #include <linux/cpumask.h>
 #include <sys/debug.h>
 #include <sys/varargs.h>
-#include <sys/zone.h>
 #include <sys/signal.h>
 
 #ifdef HAVE_SCHED_RT_HEADER
diff --git a/include/sys/zone.h b/include/sys/zone.h
index 5a3c086..e08f8cc 100644
--- a/include/sys/zone.h
+++ b/include/sys/zone.h
@@ -1,4 +1,5 @@
 /*****************************************************************************\
+ *  Copyright 2015 OmniTI Computer Consulting, Inc. All rights reserved.
  *  Copyright (C) 2007-2010 Lawrence Livermore National Security, LLC.
  *  Copyright (C) 2007 The Regents of the University of California.
  *  Produced at Lawrence Livermore National Laboratory (cf, DISCLAIMER).
@@ -26,11 +27,35 @@
 #define _SPL_ZONE_H
 
 #include <sys/byteorder.h>
+#include <sys/list.h>
+#include <sys/types.h>
 
 #define	GLOBAL_ZONEID			0
 
-#define	zone_dataset_visible(x, y)	(1)
-#define	crgetzoneid(x)			(GLOBAL_ZONEID)
-#define	INGLOBALZONE(z)			(1)
+#define	INGLOBALZONE(z)			(crgetzoneid(z) == GLOBAL_ZONEID)
+
+struct dataset_namespace;
+
+typedef unsigned long zoneid_t;
+
+typedef struct spl_zone {
+	zoneid_t    zone_id;
+	list_node_t zone_list;
+	struct dataset_namespace   *zone_namespace;
+	list_t	    zone_datasets;
+} zone_t;
+
+typedef struct zone_dataset {
+	char	    *zd_dataset;
+	list_node_t zd_linkage;
+} zone_dataset_t;
+
+extern zone_t * crgetzone(struct task_struct *task);
+extern zoneid_t crgetzoneid(struct task_struct *task);
+
+extern int zone_dataset_visible(const char *dataset, int *writable);
+
+int spl_zone_init(void);
+void spl_zone_fini(void);
 
 #endif /* SPL_ZONE_H */
diff --git a/module/spl/Makefile.in b/module/spl/Makefile.in
index a1f1ab8..8e15cab 100644
--- a/module/spl/Makefile.in
+++ b/module/spl/Makefile.in
@@ -28,3 +28,4 @@ $(MODULE)-objs += @top_srcdir@/module/spl/spl-xdr.o
 $(MODULE)-objs += @top_srcdir@/module/spl/spl-cred.o
 $(MODULE)-objs += @top_srcdir@/module/spl/spl-tsd.o
 $(MODULE)-objs += @top_srcdir@/module/spl/spl-zlib.o
+$(MODULE)-objs += @top_srcdir@/module/spl/spl-zone.o
diff --git a/module/spl/spl-generic.c b/module/spl/spl-generic.c
index 4d9846c..e86d8a1 100644
--- a/module/spl/spl-generic.c
+++ b/module/spl/spl-generic.c
@@ -40,6 +40,7 @@
 #include <sys/proc.h>
 #include <sys/kstat.h>
 #include <sys/file.h>
+#include <sys/zone.h>
 #include <linux/ctype.h>
 #include <linux/kmod.h>
 #include <linux/math64_compat.h>
@@ -549,11 +550,15 @@ spl_init(void)
 
 	if ((rc = spl_zlib_init()))
 		goto out9;
+	if ((rc = spl_zone_init()))
+		goto out10;
 
 	printk(KERN_NOTICE "SPL: Loaded module v%s-%s%s\n", SPL_META_VERSION,
 	       SPL_META_RELEASE, SPL_DEBUG_STR);
 	return (rc);
 
+out10:
+	spl_zlib_fini();
 out9:
 	spl_tsd_fini();
 out8:
@@ -583,6 +588,7 @@ spl_fini(void)
 {
 	printk(KERN_NOTICE "SPL: Unloaded module v%s-%s%s\n",
 	       SPL_META_VERSION, SPL_META_RELEASE, SPL_DEBUG_STR);
+	spl_zone_fini();
 	spl_zlib_fini();
 	spl_tsd_fini();
 	spl_kstat_fini();
diff --git a/module/spl/spl-zone.c b/module/spl/spl-zone.c
new file mode 100644
index 0000000..7c136d2
--- /dev/null
+++ b/module/spl/spl-zone.c
@@ -0,0 +1,212 @@
+/*****************************************************************************\
+ *  Copyright 2015 OmniTI Computer Consulting, Inc. All rights reserved.
+ *  Written by Albert Lee <trisk@omniti.com>.
+ *
+ *  This file is part of the SPL, Solaris Porting Layer.
+ *  For details, see <http://zfsonlinux.org/>.
+ *
+ *  The SPL is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation; either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ *  The SPL is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with the SPL.  If not, see <http://www.gnu.org/licenses/>.
+ *****************************************************************************
+ *  Solaris Porting Layer (SPL) Zones Implementation.
+\*****************************************************************************/
+
+#include <sys/zone.h>
+#include <sys/mutex.h>
+#include <sys/list.h>
+#include <sys/kmem.h>
+#include <linux/nsproxy.h>
+#include <linux/dataset_namespace.h>
+
+static kmutex_t zone_lock;
+static struct list_head zone_list;
+
+zone_t *
+crgetzone(struct task_struct *task)
+{
+	struct dataset_namespace *dsns;
+	zone_t *zone = NULL;
+
+	dsns = task->nsproxy->dataset_ns;
+	mutex_enter(&zone_lock);
+	list_for_each_entry(zone, &zone_list, zone_list)
+		if (zone->zone_namespace == dsns)
+			break;
+	mutex_exit(&zone_lock);
+
+	return (zone);
+}
+EXPORT_SYMBOL(crgetzone);
+
+zoneid_t
+crgetzoneid(struct task_struct *task)
+{
+	zone_t *zone;
+
+	zone = crgetzone(task);
+	if (zone == NULL)
+		return ((zoneid_t)-1);
+
+	return (zone->zone_id);
+}
+EXPORT_SYMBOL(crgetzoneid);
+
+static void
+zone_free_datasets(zone_t *zone)
+{
+	zone_dataset_t *zd, *next;
+
+	for (zd = list_head(&zone->zone_datasets); zd != NULL; zd = next) {
+		next = list_next(&zone->zone_datasets, zd);
+		list_remove(&zone->zone_datasets, zd);
+		kmem_free(zd->zd_dataset, strlen(zd->zd_dataset) + 1);
+		kmem_free(zd, sizeof(zone_dataset_t));
+	}
+	list_destroy(&zone->zone_datasets);
+}
+
+int
+zone_dataset_visible(const char *dataset, int *writable)
+{
+	zone_t *zone;
+	zone_dataset_t *zd, *next;
+	int len;
+
+	if (dataset == NULL || *dataset == '\0')
+		return (0);
+
+	zone = crgetzone(curproc);
+	if (zone == NULL)
+		return (0);
+
+	if (zone->zone_id == GLOBAL_ZONEID)
+	{
+		/* Global zone */
+		if (writable != NULL)
+			*writable = 1;
+		return (1);
+	}
+
+#if 1
+	/*
+	 * Demo shit.
+	 */
+	if ((strncmp(dataset, "mistify/guests/", 15) == 0) ||
+	    strncmp(dataset, "mistify/demo/", 13) == 0) {
+		if (writable != NULL)
+			*writable = 1;
+		return (1);
+	}
+	return (0);
+#endif
+	/*
+	 * Search for parents of this dataset or exact matches. If found, expose this
+	 * dataset as writable.
+	 */
+	for (zd = list_head(&zone->zone_datasets); zd != NULL; zd = next) {
+		next = list_next(&zone->zone_datasets, zd);
+		len = strlen(zd->zd_dataset);
+		if (strncmp(dataset, zd->zd_dataset, len) == 0) {
+			switch (dataset[len]) {
+			case '\0':
+			case '/':
+			case '@':
+				if (writable != NULL)
+					*writable = 1;
+				return (1);
+			}
+		}
+	}
+
+	/*
+	 *  Search for children of this dataset. If found, expose this dataset as
+	 *  read-only.
+	 */
+	len = strlen(dataset);
+	if (dataset[len - 1] == '/')
+		len--;
+	for (zd = list_head(&zone->zone_datasets); zd != NULL; zd = next) {
+		next = list_next(&zone->zone_datasets, zd);
+		if (strncmp(dataset, zd->zd_dataset, len) == 0 &&
+		    zd->zd_dataset[len] == '/') {
+			if (writable != NULL)
+				*writable = 0;
+			return (1);
+		}
+	}
+
+	return (0);
+}
+EXPORT_SYMBOL(zone_dataset_visible);
+
+static int
+zone_init(struct dataset_namespace *ns)
+{
+	zone_t *zone;
+
+	zone = kmem_alloc(sizeof (zone_t), KM_SLEEP);
+	zone->zone_id = ns->ns.inum;
+	if (ns == &init_dataset_ns)
+		zone->zone_id = GLOBAL_ZONEID;
+	zone->zone_namespace = ns;
+	list_create(&zone->zone_datasets, sizeof (zone_dataset_t),
+	    offsetof(zone_dataset_t, zd_linkage));
+	mutex_enter(&zone_lock);
+	list_add_tail(&zone->zone_list, &zone_list);
+	mutex_exit(&zone_lock);
+
+	return (0);
+}
+
+
+static void
+zone_exit(struct dataset_namespace *ns)
+{
+	zone_t *zone;
+
+	mutex_enter(&zone_lock);
+	list_for_each_entry(zone, &zone_list, zone_list)
+		if (zone->zone_namespace == ns)
+			break;
+	list_del(&zone->zone_list);
+	mutex_exit(&zone_lock);
+	zone_free_datasets(zone);
+	kmem_free(zone, sizeof (zone_t));
+}
+
+static struct dataset_operations zone_operations = {
+	.init = zone_init,
+	.exit = zone_exit,
+};
+
+int
+spl_zone_init(void)
+{
+	int error = 0;
+
+	mutex_init(&zone_lock, NULL, MUTEX_DEFAULT, NULL);
+	INIT_LIST_HEAD(&zone_list);
+	error = register_dataset_provider(&zone_operations);
+	if (error != 0)
+		mutex_destroy(&zone_lock);
+
+	return (error);
+}
+
+void
+spl_zone_fini(void)
+{
+	unregister_dataset_provider(&zone_operations);
+	mutex_destroy(&zone_lock);
+}
+
