#!/bin/bash
#+
# Use this script to initialize a Buildroot based build environment for Mistify.
#
# The intent is to use a copy of the Buildroot build envirnment for Buildroot 
# unmodified and using an external project directory.
#-


#+
# TODO: buildroottag needs to be updated at release time to use the tag corresponding
# to the release.
#-
bruridefault=git@github.com:mistifyio/buildroot.git
buildrootdirdefault=$PWD/build/buildroot
buildrootbranchdefault="master"
buildroottagdefault=

builddirdefault=$PWD/build/mistify
variantdirdefault=base
downloaddirdefault=$PWD/downloads
mistifycfgdefault=$PWD/configs/mistify_defconfig
kernelcfgdefault=$PWD/configs/mistify-kernel.config
busyboxcfgdefault=$PWD/configs/mistify-busybox.config

usage () {
    cat << EOF
Usage: ./buildmistify [options] [target]
  This script must be run from within the project directory. It uses the
  Buildroot build environment to build Mistify-OS using Buildroot.
  If the Buildroot build environment is not present then it is first cloned from
  the Mistify repository.
  Buildroot is configured to use an external toolchain. If the external
  toolchain is not present then it is installed before starting Buildroot.
  Options:
    ==== external toolchain ====
    --tcuri <uri>
        The repository from which to clone Buildroot. This is saved in the file
        $statedir/tcuri.
        [tcuri=`cat $statedir/tcuri`]
    --toolchaindir <dir>
        Where the toolchain is to be installed and defaults to:
        <builddir>/toolchain. Using this option simplifies using a single
        toolchain install for multiple projects OR using different toolchain
        versions for different projects. This is saved in the file
        $statedir/toolchaindir.
        [toolchaindir=`cat $statedir/toolchaindir`]
    --toolchainprefix <prefix>
        This is the toolchain prefix to use to select a specific build of the
        toolchain. This is saved in the file
        $statedir/toolchainprefix
        [toolchainprefix=`cat $statedir/toolchainprefix`]
    --toolchainbranch <label>
        Checkout the toolchain using a specified branch. NOTE: This option
        supercedes the --toolchaintag option. The branch name is saved in the
        file $statedir/toolchainbranch.
        [toolchainbranch=`cat $statedir/toolchainbranch`]
    --toolchaintag <tag>
        Checkout the toolchain using a specific tag. To reset to the master
        branch use the --toolchainbranch option. The tag is saved in the file
        $statedir/toolchaintag.
        [toolchaintag=`cat $statedir/toolchaintag`]
    ==== go ====
    --godir <dir>
        Where the GO source code is cloned to before building. This is saved in
        the file $statedir/godir.
        [godir=`cat $statedir/godir`]
    --gouri default|<uri>
        The repository from which to clone the GO source code. Use "default"
        to reset to the default URI. 
        This is saved in the file $statedir/gouri.
        [gouri=`cat $statedir/gouri`]
    --gotag default|<tag>
        The tag to use when fetching the GO source code from the repository.
        Use "default" to reset to the default repository tag.
        This is saved in the file $statedir/gotag.
        [gotag=`cat $statedir/gotag`]
    ==== buildroot ====
    --bruri <uri>
        The repository from which to clone Buildroot. This is saved in the file
        $statedir/bruri.
        [bruri=`cat $statedir/bruri`]
    --buildroot <dir>
        Where Buildroot is to be installed. Using this option simplifies using a
        single Buildroot install for multiple projects OR using different
        versions of Buildroot for different projects. This is saved in the file
        $statedir/buildroot.
        [buildroot=`cat $statedir/buildroot`]
    --buildrootbranch <label>
        Checkout Buildroot using a specified branch. NOTE: This option
        supercedes the --buildroottag option. The branch name is saved in the
        file $statedir/buildrootbranch.
        [buildrootbranch=`cat $statedir/buildrootbranch`]
    -t:--buildroottag <tag>
        Checkout Buildroot using a specific tag. To reset to the master branch
        use the --buildrootbranch option. The tag is saved in the file
        $statedir/buildroottag.
        [buildroottag=`cat $statedir/buildroottag`]
    ==== build ====
    -b|--builddir <dir>
        Where to put the build targets and output. This location is saved in the
        file $statedir/builddir.
        [builddir=`cat $statedir/builddir`]
    -d|--downloaddir <dir>
        Where the downloaded source files are stored. Use this directory instead
        of downloading a new set. This helps avoid downloading new files when
        changing one of the other directories.
        WARNING: This overrides the Buildroot configuration option.
        [downloaddir=`cat $statedir/downloaddir`]
    ==== configuration ====
    --variant <variant>
        Use a configuration variant. The variant is always based upon the
        base configuration files indicated by the --config, --kconfig, 
        --bbconfig and --tcconfig options. To reset to the base configuration
        use an empty string as the variant name. e.g. --variant ''
        The active variant name is saved in the file
        $statedir/variant.
        [variant=`cat $statedir/variant`]
    -c|--config <configfile>
        Use this config file. The config file is copied to the build directory
        before running the buildroot make. NOTE: The latest Buildroot from the
        repository supports a configuration option for this but the make file
        doesn't use it yet. The file name is saved in the file 
        $statedir/config.
        [config=`cat $statedir/config`]
    -k|--kconfig <configfile>
        Use this kernel config file. The config file is copied to the build
        directory before running the buildroot make. NOTE: The latest Buildroot
        from the repository supports a configuration option for this but the
        make file doesn't use it yet.  The file name is saved in the file
        $statedir/config.
        [kconfig=`cat $statedir/kconfig`]
    --bbconfig <configfile>
        Use this Busybox config file. The config file is copied to the build
        directory before running the buildroot make. The file name is saved in 
        the file $statedir/bbconfig.
        [bbconfig=`cat $statedir/bbconfig 2>/dev/null || echo \\`]
    --tcconfig <configfile>
        Use this toolchain config file. The config file is copied to the
        toolchain build directory before running the toolchain build. The file
        name is saved in the file $statedir/tcconfig.
        [tcconfig=`cat $statedir/tcconfig 2>/dev/null || echo \\`]
    ==== other ====
    --verbose
        Enble verbose output from this script.
    -l|--logfile
        Use this log file name instead of the generated log file name.
    --viewlog
        If the Buildroot make returns an error then view the log file.
    --test
        Just testing what will happen with this script. Don't run the Buildroot
        make.
    -h|--help
        Display this usage.
    ==== special targets ====
    toolchain-menuconfig
        Run the toolchain configuration utility.
    menuconfig
        Run the Buildroot configuration utility.
    busybox-menuconfig
        Run the Busybox configuration utility.
    linux-menuconfig
        Run the Linux kernel configuration utility.

  NOTE: This script maintains state in $statedir.
  The targets toolchain-menuconfig, menuconfig, busybox-menuconfig and
  linux-menuconfig exit immediately after exiting the corresponding
  configuration utilities.
  Custom environment variables:
    MISTIFY_DIR = Points to the directory in which buildmistify resides. This
    can then be used in the buildroot config to specify locations of files such
    as the config file.
EOF
}

source scripts/mistify-functions.sh
source scripts/install-toolchain.sh
source scripts/install-go.sh
source scripts/variants.sh

#+
# TODO: Add some quick checks to verify required tools are installed.
#-

#+
# Handle the command line options.
#-
a=`getopt -l "\
tcuri:,\
toolchaindir:,\
toolchainprefix:,\
toolchainbranch:,\
toolchainroottag:,\
gouri:,\
godir:,\
gotag:,\
bruri:,\
buildroot:,\
buildrootbranch:,\
buildroottag:,\
builddir:,\
variant:,\
config:,\
kconfig:,\
bbconfig:,\
tcconfig:,\
test,\
downloaddir:,\
verbose,\
logfile:,\
viewlog,\
help" \
   -o "c:k:b:t:l:d:h" -- "$@"`

if [ $? -gt 0 ]; then
    usage
    exit 1
fi

eval set -- $a

while [ $# -ge 1 ]; do
    case "$1" in
	--)
	    shift
	    break
	    ;;
	--tcuri)
	    tcuri=$2
	    shift
	    ;;
	--toolchaindir)
	    toolchaindir=$2
	    shift
	    ;;
	--toolchainprefix)
	    toolchainprefix=$2
	    shift
	    ;;
	--toolchainbranch)
	    toolchainbranch=$2
	    shift
	    ;;
	--toolchaintag)
	    toolchaintag=$2
	    shift
	    ;;
	--gouri)
	    gouri=$2
	    shift
	    ;;
	--godir)
	    godir=$2
	    shift
	    ;;
	--gotag)
	    gotag=$2
	    shift
	    ;;
	--bruri)
	    bruri=$2
	    shift
	    ;;
	--buildroot)
	    buildrootdir=$2
	    shift
	    ;;
	--buildrootbranch)
	    buildrootbranch=$2
	    shift
	    ;;
	-t|--buildroottag)
	    buildroottag=$2
	    shift
	    ;;
	-b|--builddir)
	    builddir=$2
	    shift
	    ;;
	-d|--downloaddir)
	    downloaddir=$2
	    shift
	    ;;
	--variant)
	    variant=$2
	    # This variable helps handle the case where the variant is being
	    # reset to the base ('').
	    variantset=y
	    shift
	    ;;
	-c|--config)
	    mistifycfg=$2
	    shift
	    ;;
	-k|--kconfig)
	    kernelcfg=$2
	    shift
	    ;;
	--bbconfig)
	    busyboxcfg=$2
	    shift
	    ;;
	--tcconfig)
	    tcconfig=$2
	    shift
	    ;;
	--verbose)
	    verbose=y
	    ;;
	-l|--logfile)
	    logfilename=$2
	    shift
	    ;;
	--viewlog)
	    viewlog=y
	    ;;
	--test)
	    testing=y
	    ;;
	-h|--help)
	    usage
	    exit 0
	    ;;
	# using getopt should avoid needing this catchall but just in case...
	*)
	    error "Invalid option: $1"
	    usage
	    exit 1
	    ;;
    esac
    shift
done

if [[ $# -ge 1 ]]; then
  target=$1
  message "Building target: $target"
  # Any other arguments are ignored at this point.
else
  t=""
fi

if [ ! -e $statedir ]; then
  mkdir -p $statedir
fi

#+
# Determine the location of the Buildroot directory.
# NOTE: The directory does not need to exist because the Buildroot init script will
# create it if necessary.
#-
if [ -z "$buildrootdir" ]; then
  if [ -f $statedir/buildroot ]; then
    buildrootdir=`cat $statedir/buildroot`
  else
    buildrootdir=$buildrootdirdefault
  fi
  message "Using Buildroot located at: $buildrootdir"
fi
echo $buildrootdir >$statedir/buildroot

#+
# Determine the configuration variant to use.
# If variant is null but was set on the command line then reset to the base.
#-
if [ -z "$variant" ]; then
  if [ "$variantset" == "y" ]; then
     rm $statedir/variant
  fi
  if [ -f $statedir/variant ]; then
    variant=`cat $statedir/variant`
  fi
fi
if [ -z "$variant" ]; then
  message "Using base configuration."
  variantdir=$variantdirdefault
else
  message "The configuration variant is: $variant"
  variantdir=$variant
  echo $variant >$statedir/variant
fi

#+
# Determine the location of the build directory.
# NOTE: The directory does not need to exist because the Buildroot make will
# create it if necessary.
#-
if [ -z "$builddir" ]; then
  if [ -f $statedir/builddir ]; then
    builddir=`cat $statedir/builddir`
  else
    builddir=$builddirdefault
  fi
fi
if [ ! -d "$builddir" ]; then
    mkdir -p $builddir
fi
message "Build output directory is: $builddir"
echo $builddir >$statedir/builddir

variantbuilddir=$builddir/$variantdir

logdir=$variantbuilddir/logs
mkdir -p $logdir

#+
# Determine the uri to use to fetch the Buildroot tool.
#-
if [ -z "$bruri" ]; then
  if [ -f $statedir/bruri ]; then
    bruri=`cat $statedir/bruri`
  else
    bruri=$bruridefault
  fi
fi
message "The Buildroot repository is: $bruri"
echo $bruri >$statedir/bruri

#+
# If the buildrootbranch option is used then ignore the buildroottag option.
# NOTE: Specifying a branch overrides using a tag.
#-
if [ ! -z "$buildrootbranch" ]; then
  message "Switching to branch: $buildrootbranch"
  if [ ! -z "$buildroottag" ]; then
    warning "Ignoring --buildroottag"
    buildroottag=
  fi
  rm -f $statedir/buildroottag
else
  if [ -f $statedir/buildrootbranch ]; then
    buildrootbranch=`cat $statedir/buildrootbranch`
  else
    buildrootbranch=$buildrootbranchdefault
  fi
fi
echo $buildrootbranch >$statedir/buildrootbranch

if [ ! -f $buildrootdir/README ]; then
  message 'Fetching Buildroot branch "master" from the Buildroot project repository.'
  git clone $bruri $buildrootdir
  #+
  # TODO: It is possible that the previous clone failed. Might want to use
  # git again to update just in case.
  #-
  if [ $? -gt 0 ]; then
    error "Fetching Buildroot encountered an error."
    exit 1
  fi
fi
cd $buildrootdir

#+
# Determine the tag to use to sync Buildroot to.
# NOTE: Having branch and tag separate helps avoid an ambiguity which could
# result in accidentally creating a branch when a tag was intended.
# NOTE: If buildroottag is set at this point then it wasn't overridden by  
# specifying a branch.
#-
if [ ! -z "$buildroottag" ]; then
  buildrootbranch=
  message "Switching to buildroot tag: $buildroottag"
  echo $buildroottag >$statedir/buildroottag
else
  if [ -f $statedir/buildroottag ]; then
    buildrootbranch=
    buildroottag=`cat $statedir/buildroottag`
  fi
fi

#+
# Verify using the desired Buildroot version. If the branch or tag doesn't exist
# locally then fetch an update from the repo.
#-
if [ ! -z "$buildroottag" ]; then
  message "Using Buildroot tag: $buildroottag"
  git tag | grep $buildroottag
  if [ $? -ne 0 ]; then
    message "Local tag $buildroottag doesn't exist."
    message "Fetching update from remote repository."
    git fetch
  fi
  buildrootlabel="tags/$buildroottag"
else
  message "Using Buildroot branch: $buildrootbranch"
  git branch | grep $buildrootbranch
  if [ $? -ne 0 ]; then
    message "Local branch $buildrootbranch doesn't exist."
    message "Fetching update from remote repository."
    git fetch
  fi
  buildrootlabel=$buildrootbranch
fi

git checkout $buildrootlabel
if [ $? -ne 0 ]; then
  error "Attempted to checkout Buildroot using an invalid tag or branch: $buildrootlabel"
  exit 1
fi
message "Buildroot synced to: $buildrootlabel"
cd $projectdir

#+
# Setup the correct project config file.
#-
if [ -z "$mistifycfg" ]; then
  if [ -f $statedir\$mistifycfg ]; then
    mistifycfg=`cat $statedir/config`
  else
    mistifycfg=$mistifycfgdefault
  fi
fi

buildrootkernelheaders=`grep BR2_LINUX_KERNEL_VERSION $mistifycfg | cut -d \" -f 2`

message "The Buildroot config file is: $mistifycfg"
message "The kernel headers version is: $buildrootkernelheaders"

brc=$variantbuilddir/.config
if [ -f $mistifycfg ]; then
  use_variant $mistifycfg $brc $variant
  if [ $? -gt 0 ]; then
    error "Could not copy the Buildroot config file."
    exit 1
  fi
  message "Config file $mistifycfg copied to $brc"
  echo $mistifycfg >$statedir/config
else
  case "$target" in
    "menuconfig" | "nconfig")
      ;;
    *)
      error "The config file doesn't exist. Run $0 menuconfig."
      exit 1
      ;;
  esac
fi

#+
# Setup the correct kernel config file.
# TODO: Add a check to verify the kernel config file exists.
#
if [ -z "$kernelcfg" ]; then
  if [ -f $statedir/kconfig ]; then
    kernelcfg=`cat $statedir/kconfig`
  else
    kernelcfg=$kernelcfgdefault
  fi
fi
message "The Buildroot kernel config file is: $kernelcfg"

brkc=$variantbuilddir/build/linux-`grep BR2_LINUX_KERNEL_VERSION $brc | cut -d "\"" -f 2`/.config

if [ -f $brkc ]; then
  if [ -f $kernelcfg ]; then
    use_variant $kernelcfg $brkc $variant
    if [ $? -gt 0 ]; then
      error "Could not copy the kernel config file."
      exit 1
    fi
    message "Config file $kernelcfg copied to $brkc"
    echo $kernelcfg >$statedir/kconfig
  else
    if [[ "$target" != "linux-menuconfig" ]]; then
      error "The kernel config file doesn't exist. Run ./buildmistify linux-menuconfig."
      exit 1
    fi
  fi
fi

#+
# Setup the correct busybox config file.
#
if [ -z "$busyboxcfg" ]; then
  if [ -f $statedir/bbconfig ]; then
    busyboxcfg=`cat $statedir/bbconfig`
  else
    busyboxcfg=$busyboxcfgdefault
  fi
fi
message "The Buildroot BusyBox config file is: $busyboxcfg"

bbc=`ls -d $variantbuilddir/build/busybox-*`/.config

if [ -f $bbc ]; then
  if [ -f $busyboxcfg ]; then
    if [[ $busyboxcfg -nt $bbc ]]; then
      use_variant $busyboxcfg $bbc $variant
      if [ $? -gt 0 ]; then
        warning "Busybox hasn't been built yet."
      fi
      message "Config file $busyboxcfg copied to $bbc"
      echo $busyboxcfg >$statedir/bbconfig
    fi
  else
    if [[ "$target" != "busybox-menuconfig" ]]; then
      error "The BusyBox config file doesn't exist."
      message "Run ./buildmistify busybox-menuconfig."
      exit 1
    fi
  fi
fi

#+
# Setup the downloads directory.
#-
if [ -z "$downloaddir" ]; then
  if [ -f $statedir/downloaddir ]; then
    downloaddir=`cat $statedir/downloaddir`
  else
    downloaddir=$downloaddirdefault
  fi
fi
echo $downloaddir >$statedir/downloaddir

message "The Buildroot download directory is: $downloaddir"

message "Project dir: $projectdir"

#+
# Be sure the toolchain is installed.
#-
install-toolchain
if [[ $? -gt 0 ]]; then
    #+
    # If the toolchain was built then a full rebuild is needed.
    #-
    warning "The toolchain has changed. A full target rebuild is recommended."
    warning "Run ./buildmistify clean and then ./buildmistify to rebuild."
    exit
fi
install-go

#+
# Enter the buildroot tree.
#-
cd $buildrootdir

#+
# Now run the build.
#-
export MISTIFY_DIR=$projectdir
makecommand="\
make O=$variantbuilddir \
TOOLCHAIN_PATH=$TC_PREFIX_DIR TOOLCHAIN_PREFIX=$toolchainprefix \
BR2_CCACHE_DIR=$builddir/.buildroot_ccache \
BR2_DL_DIR=$downloaddir BR2_EXTERNAL=$projectdir \
BR2_DEFAULT_KERNEL_HEADERS=$buildrootkernelheaders \
GOROOT=$GOROOT \
$target"

#+
# Don't run the build if changing configurations.
#-
case "$target" in
    "menuconfig" | "nconfig")
	$makecommand
	if [[ ! -f $mistifycfg || $brc -nt $mistifycfg ]]; then
	    #+
	    # NOTE: The buildroot config option BR2_DEFCONFIG
	    # needs to point to the config file so that buildroot will copy the correct
	    # file on the first build.
	    #-
	   update_variant $brc $mistifycfg $variant
	    if [ $? -gt 0 ]; then
		error "Failed to save $mistifycfg"
		exit 1
	    fi
	    tip "Use $0 to build Mistify using the new configuration."
	    message "New config file at $brc saved to $mistifycfg"
	fi
	exit
	;;
    "xconfig" | "gconfig")
	error "Configuration tool $target is not supported."
	exit 1
	;;
    "linux-menuconfig")
	#+
	# NOTE: The buildroot config option BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE
	# needs to point to the config file so that buildroot will copy the correct
	# file on the first build.
	#-
	$makecommand
	if [[ ! -f $kernelcfg || $brkc -nt $kernelcfg ]]; then
	    update_variant $brkc $kernelcfg $variant
	    if [ $? -gt 0 ]; then
		error "Failed to save $kernelcfg"
		exit 1
	    fi
	    tip "Use $0 to build Mistify using the new configuration."
	    message "New kernel config file at $brkc saved to $kernelcfg"
	fi
	exit
	;;
    "busybox-menuconfig")
	#+
	# NOTE: The buildroot config option BR2_PACKAGE_BUSYBOX_CONFIG
	# needs to point to the config file so that buildroot will copy the correct
	# file on the first build.
	#-
	$makecommand
	# NOTE: May want to use grep instead of a timestamp compare.
	if [[ ! -f $busyboxcfg || $bbc -nt $busyboxcfg ]]; then
	    update_variant $bbc $busyboxcfg $variant
	    if [ $? -gt 0 ]; then
		error "Failed to save $busyboxcfg"
		exit 1
	    fi
	    tip "Use $0 to build Mistify using the new configuration."
	    message "New BusyBox config file $bbc saved to $busyboxcfg"
	fi
	exit
	;;
    *)
	;;
esac

#+
# Setup the build log file.
#-
if [ -n "$logfilename" ]; then
  logfile=$logdir/$logfilename
else
  logfile=$logdir/buildroot-`date +%y%m%d%H%M%S`.log
fi
message "Logging the build output to: $logfile"

#+
# Run buildroot.
#-
if [ -n "$testing" ]; then
  message "Just a test run -- not running make."
  verbose $makecommand
else
  #+
  # Run the buildroot make.
  #-
  time $makecommand 2>&1 | tee $logfile
  if [ ${PIPESTATUS[0]} -gt 0 ]; then
    error "Make complained about a build problem (see $logfile)."
    if [ -n "$viewlog" ]; then
      less $logfile
    fi
    exit 1
  fi
fi

imagedir=$variantbuilddir/images
if [ -f $imagedir/rootfs.cpio.gz ]; then
  ln -sf $imagedir/rootfs.cpio.gz $imagedir/initrd.buildroot
else
  message "The initrd doesn't exist."
fi
if [ -f $imagedir/bzImage ]; then
  ln -sf $imagedir/bzImage $imagedir/bzImage.buildroot
else
  message "The kernel image doesn't exist."
fi

ln -sf $logfile $logdir/buildroot.Log

message "The log file is: $logfile"
message "Images are in $imagedir and can be uploaded to the server."
message "bzImage.buildroot: The kernel image."
message "initrd.buildroot: The RAM disk."
if [ -e $imagedir ]; then
  ls -l $imagedir
fi

