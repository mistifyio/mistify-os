#!/bin/bash
#+
# Use this script to initialize a Buildroot based build environment for Mistify.
#
# The intent is to use a copy of the Buildroot build envirnment for Buildroot
# unmodified and using an external project directory.
#-


#+
# TODO: buildroottag needs to be updated at release time to use the tag corresponding
# to the release.
#-
bruridefault=git@github.com:mistifyio/buildroot.git
buildrootdirdefault=$PWD/build/buildroot
buildrootbranchdefault="master"
buildroottagdefault="20150424"

builddirdefault=$PWD/build/mistify
variantdirdefault=base
downloaddirdefault=$PWD/downloads
mistifycfgdefault=$PWD/configs/mistify_defconfig
kernelcfgdefault=$PWD/configs/mistify-kernel.config
busyboxcfgdefault=$PWD/configs/mistify-busybox.config

timestampfile=/tmp/buildmistify-ts

usage () {
    cat << EOF
Usage: ./buildmistify [options] [target]
  This script must be run from within the project directory. It uses the
  Buildroot build environment to build Mistify-OS using Buildroot.
  If the Buildroot build environment is not present then it is first cloned from
  the Mistify repository.
  Buildroot is configured to use an external toolchain. If the external
  toolchain is not present then it is installed before starting Buildroot.
  Options:
    ==== external toolchain ====
    --tcuri <uri>
        The repository from which to clone Buildroot. This is saved in the file
        $statedir/tcuri.
        [tcuri=`cat $statedir/tcuri`]
    --toolchaindir <dir>
        Where the toolchain is to be installed and defaults to:
        <builddir>/toolchain. Using this option simplifies using a single
        toolchain install for multiple projects OR using different toolchain
        versions for different projects. This is saved in the file
        $statedir/toolchaindir.
        [toolchaindir=`cat $statedir/toolchaindir`]
    --toolchainprefix <prefix>
        This is the toolchain prefix to use to select a specific build of the
        toolchain. This is saved in the file
        $statedir/toolchainprefix
        [toolchainprefix=`cat $statedir/toolchainprefix`]
    --toolchainversion <version>
        Checkout the toolchain using a specified version. This can be a branch
        or tag name or even a commit ID. The branch name is saved in the
        file $statedir/toolchainversion.
        [toolchainversion=`cat $statedir/toolchainversion`]
    --toolchainreset
	Reset the toolchain related options to their defaults.
    ==== go ====
    --godir <dir>
        Where the GO source code is cloned to before building. This is saved in
        the file $statedir/godir.
        [godir=`cat $statedir/godir`]
    --gouri default|<uri>
        The repository from which to clone the GO source code. Use "default"
        to reset to the default URI.
        This is saved in the file $statedir/gouri.
        [gouri=`cat $statedir/gouri`]
    --gotag default|<tag>
        The tag to use when fetching the GO source code from the repository.
        Use "default" to reset to the default repository tag.
        This is saved in the file $statedir/gotag.
        [gotag=`cat $statedir/gotag`]
    ==== buildroot ====
    --bruri <uri>
        The repository from which to clone Buildroot. This is saved in the file
        $statedir/bruri.
        [bruri=`cat $statedir/bruri`]
    --buildroot <dir>
        Where Buildroot is to be installed. Using this option simplifies using a
        single Buildroot install for multiple projects OR using different
        versions of Buildroot for different projects. This is saved in the file
        $statedir/buildroot.
        [buildroot=`cat $statedir/buildroot`]
    --buildrootbranch <label>
        Checkout Buildroot using a specified branch. NOTE: This option
        supercedes the --buildroottag option. The branch name is saved in the
        file $statedir/buildrootbranch.
        [buildrootbranch=`cat $statedir/buildrootbranch`]
    -t|--buildroottag <tag>
        Checkout Buildroot using a specific tag. To reset to the master branch
        use the --buildrootbranch option. The tag is saved in the file
        $statedir/buildroottag.
        [buildroottag=`cat $statedir/buildroottag`]
    ==== build ====
    -b|--builddir <dir>
        Where to put the build targets and output. This location is saved in the
        file $statedir/builddir.
        [builddir=`cat $statedir/builddir`]
    -d|--downloaddir <dir>
        Where the downloaded source files are stored. Use this directory instead
        of downloading a new set. This helps avoid downloading new files when
        changing one of the other directories.
        WARNING: This overrides the Buildroot configuration option.
        [downloaddir=`cat $statedir/downloaddir`]
    --resetmasters
        Some packages may be configured to always pull from the master branch.
        This can result in stale copies in the download cache being used for the
        build. This option causes these files to be removed before starting the build.
    ==== configuration ====
    --variant <variant>
        Use a configuration variant. The variant is always based upon the
        base configuration files indicated by the --config, --kconfig,
        --bbconfig and --tcconfig options. To reset to the base configuration
        use an empty string as the variant name. e.g. --variant ''
        The active variant name is saved in the file
        $statedir/variant.
        [variant=`cat $statedir/variant`]
    -c|--config <configfile>
        Use this config file. The config file is copied to the build directory
        before running the buildroot make. The file name is saved in the file
        $statedir/config.
        [config=`cat $statedir/config`]
    -k|--kconfig <configfile>
        Use this kernel config file. The config file is copied to the build
        directory before running the buildroot make.  The file name is saved in
        the file
        $statedir/config.
        [kconfig=`cat $statedir/kconfig`]
    --bbconfig <configfile>
        Use this Busybox config file. The config file is copied to the build
        directory before running the buildroot make. The file name is saved in
        the file $statedir/bbconfig.
        [bbconfig=`cat $statedir/bbconfig 2>/dev/null || echo \\`]
    --tcconfig <configfile>
        Use this toolchain config file. The config file is copied to the
        toolchain build directory before running the toolchain build. The file
        name is saved in the file $statedir/tcconfig.
        [tcconfig=`cat $statedir/tcconfig 2>/dev/null || echo \\`]
    ==== other ====
    --verbose
        Enble verbose output from this script.
    -l|--logfile
        Use this log file name instead of the generated log file name.
    --viewlog
        If the Buildroot make returns an error then view the log file.
    --dryrun
        Just showing what will happen with this script without running the
        Buildroot make.
    -h|--help
        Display this usage.
    ==== special targets ====
    toolchain-menuconfig
        Run the toolchain configuration utility.
    menuconfig
        Run the Buildroot configuration utility.
    busybox-menuconfig
        Run the Busybox configuration utility.
    linux-menuconfig
        Run the Linux kernel configuration utility.

  NOTE: This script maintains state in $statedir.
  The targets toolchain-menuconfig, menuconfig, busybox-menuconfig and
  linux-menuconfig exit immediately after exiting the corresponding
  configuration utilities.
  Custom environment variables:
    MISTIFY_DIR = Points to the directory in which buildmistify resides. This
    can then be used in the buildroot config to specify locations of files such
    as the config file.
EOF
}

source scripts/mistify-functions.sh
source scripts/install-toolchain.sh
source scripts/install-go.sh
source scripts/variants.sh

#+
# TODO: Add some quick checks to verify required tools are installed.
#-

#+
# Handle the command line options.
#-
a=`getopt -l "\
tcuri:,\
toolchaindir:,\
toolchainprefix:,\
toolchainversion:,\
toolchainreset,\
gouri:,\
godir:,\
gotag:,\
bruri:,\
buildroot:,\
buildrootbranch:,\
buildroottag:,\
builddir:,\
variant:,\
config:,\
kconfig:,\
bbconfig:,\
tcconfig:,\
dryrun,\
downloaddir:,\
resetmasters,\
verbose,\
logfile:,\
viewlog,\
help" \
   -o "c:k:b:t:l:d:h" -- "$@"`

if [ $? -gt 0 ]; then
    usage
    exit 1
fi

eval set -- $a

while [ $# -ge 1 ]; do
    case "$1" in
	--)
	    shift
	    break
	    ;;
	--tcuri)
	    tcuri=$2
	    shift
	    ;;
	--toolchaindir)
	    toolchaindir=$2
	    shift
	    ;;
	--toolchainprefix)
	    toolchainprefix=$2
	    shift
	    ;;
	--toolchainversion)
	    toolchainversion=$2
	    shift
	    ;;
	--toolchainreset)
	    toolchainreset=y
	    ;;
	--gouri)
	    gouri=$2
	    shift
	    ;;
	--godir)
	    godir=$2
	    shift
	    ;;
	--gotag)
	    gotag=$2
	    shift
	    ;;
	--bruri)
	    bruri=$2
	    shift
	    ;;
	--buildroot)
	    buildrootdir=$2
	    shift
	    ;;
	--buildrootbranch)
	    buildrootbranch=$2
	    shift
	    ;;
	-t|--buildroottag)
	    buildroottag=$2
	    shift
	    ;;
	-b|--builddir)
	    builddir=$2
	    shift
	    ;;
	-d|--downloaddir)
	    downloaddir=$2
	    shift
	    ;;
	--resetmasters)
	    resetmasters=y
	    ;;
	--variant)
	    variant=$2
	    # This variable helps handle the case where the variant is being
	    # reset to the base ('').
	    variantset=y
	    shift
	    ;;
	-c|--config)
	    mistifycfg=$2
	    shift
	    ;;
	-k|--kconfig)
	    kernelcfg=$2
	    shift
	    ;;
	--bbconfig)
	    busyboxcfg=$2
	    shift
	    ;;
	--tcconfig)
	    tcconfig=$2
	    shift
	    ;;
	--verbose)
	    verbose=y
	    ;;
	-l|--logfile)
	    logfilename=$2
	    shift
	    ;;
	--viewlog)
	    viewlog=y
	    ;;
	--dryrun)
	    dryrun=y
	    ;;
	-h|--help)
	    usage
	    exit 0
	    ;;
	# using getopt should avoid needing this catchall but just in case...
	*)
	    error "Invalid option: $1"
	    usage
	    exit 1
	    ;;
    esac
    shift
done

if [[ $# -ge 1 ]]; then
  target="$@"
  message "Building target: $target"
  # Any other arguments are passed to buildroot.
else
  t=""
fi

if [ ! -e $statedir ]; then
  mkdir -p $statedir
fi

#+
# Determine the location of the Buildroot directory.
# NOTE: The directory does not need to exist because the Buildroot init script will
# create it if necessary.
#-
if [ -z "$buildrootdir" ]; then
  if [ -f $statedir/buildroot ]; then
    buildrootdir=`cat $statedir/buildroot`
  else
    buildrootdir=$buildrootdirdefault
  fi
  message "Using Buildroot located at: $buildrootdir"
fi
echo $buildrootdir >$statedir/buildroot

#+
# Determine the configuration variant to use.
# If variant is null but was set on the command line then reset to the base.
#-
if [ -z "$variant" ]; then
  if [ "$variantset" == "y" ]; then
     rm $statedir/variant
  fi
  if [ -f $statedir/variant ]; then
    variant=`cat $statedir/variant`
  fi
fi
if [ -z "$variant" ]; then
  message "Using base configuration."
  variantdir=$variantdirdefault
  variant=$variantdirdefault
else
  message "The configuration variant is: $variant"
  variantdir=$variant
  echo $variant >$statedir/variant
fi

export MISTIFY_VARIANT="$variant"

#+
# Determine the location of the build directory.
# NOTE: The directory does not need to exist because the Buildroot make will
# create it if necessary.
#-
if [ -z "$builddir" ]; then
  if [ -f $statedir/builddir ]; then
    builddir=`cat $statedir/builddir`
  else
    builddir=$builddirdefault
  fi
fi
if [ ! -d "$builddir" ]; then
    mkdir -p $builddir
fi
message "Build output directory is: $builddir"
echo $builddir >$statedir/builddir

variantbuilddir=$builddir/$variantdir
message "The variant build directory is: $variantbuilddir"
# Save the variant builddir so testmistify can know which build to test.
echo $variantbuilddir >$statedir/variantbuilddir

logdir=$variantbuilddir/logs
mkdir -p $logdir

#+
# Determine the uri to use to fetch the Buildroot tool.
#-
if [ -z "$bruri" ]; then
  if [ -f $statedir/bruri ]; then
    bruri=`cat $statedir/bruri`
  else
    bruri=$bruridefault
  fi
fi
message "The Buildroot repository is: $bruri"
echo $bruri >$statedir/bruri

#+
# Check the buildroot tag. If this is the first time, meaning not saved in the
# the statedir then use the default.
#-
if [ -z "$buildroottag" ]; then
  if [ -f $statedir/buildroottag ]; then
    buildroottag=`cat $statedir/buildroottag`
  else
    buildroottag=$buildroottagdefault
  fi
else
  #+
  # Using the tag on the command line overrides the branch.
  #-
  warning "Ignoring the buildroot branch because a new tag is being used."
  rm -f $statedir/buildrootbranch
fi

#+
# If the buildrootbranch option is used then ignore the buildroottag.
# NOTE: Specifying a branch overrides using a tag.
#-
if [ ! -z "$buildrootbranch" ]; then
  message "Switching to branch: $buildrootbranch"
  if [ ! -z "$buildroottag" ]; then
    warning "Ignoring --buildroottag"
    buildroottag=
  fi
  rm -f $statedir/buildroottag
else
  if [ -f $statedir/buildrootbranch ]; then
    buildrootbranch=`cat $statedir/buildrootbranch`
    buildroottag=
  else
    buildrootbranch=$buildrootbranchdefault
  fi
fi
echo $buildrootbranch >$statedir/buildrootbranch

if [ ! -f $buildrootdir/README ]; then
  message 'Fetching Buildroot branch "master" from the Buildroot project repository.'
  git clone $bruri $buildrootdir
  #+
  # TODO: It is possible that the previous clone failed. Might want to use
  # git again to update just in case.
  #-
  if [ $? -gt 0 ]; then
    error "Fetching Buildroot encountered an error."
    exit 1
  fi
fi
cd $buildrootdir

#+
# Determine the tag to use to sync Buildroot to.
# NOTE: Having branch and tag separate helps avoid an ambiguity which could
# result in accidentally creating a branch when a tag was intended.
# NOTE: If buildroottag is set at this point then it wasn't overridden by
# specifying a branch.
#-
if [ ! -z "$buildroottag" ]; then
  buildrootbranch=
  message "Switching to buildroot tag: $buildroottag"
  echo $buildroottag >$statedir/buildroottag
else
  if [ -f $statedir/buildroottag ]; then
    buildrootbranch=
    buildroottag=`cat $statedir/buildroottag`
  fi
fi

#+
# Verify using the desired Buildroot version. If the branch or tag doesn't exist
# locally then fetch an update from the repo.
#-
if [ ! -z "$buildroottag" ]; then
  message "Using Buildroot tag: $buildroottag"
  git tag | grep $buildroottag
  if [ $? -ne 0 ]; then
    message "Local tag $buildroottag doesn't exist."
    message "Fetching update from remote repository."
    run git fetch
  fi
  buildrootlabel="tags/$buildroottag"
else
  message "Using Buildroot branch: $buildrootbranch"
  run git branch | grep $buildrootbranch
  if [ $? -ne 0 ]; then
    message "Local branch $buildrootbranch doesn't exist."
    message "Fetching update from remote repository."
    run git fetch
  fi
  buildrootlabel=$buildrootbranch
fi

run git checkout $buildrootlabel
if [ $? -ne 0 ]; then
  error "Attempted to checkout Buildroot using an invalid tag or branch: $buildrootlabel"
  exit 1
fi
#+
# Using a tag causes a "detached HEAD" state. Can't use a pull in that case.
#-
if [ -z "$buildroottag" ]; then
  message Updating buildroot for branch: $buildrootbranch
  run git pull
fi
message "Buildroot synced to: $buildrootlabel"
cd $projectdir

#+
# Setup the correct project config file.
#-
if [ -z "$mistifycfg" ]; then
  if [ -f $statedir\$mistifycfg ]; then
    mistifycfg=`cat $statedir/config`
  else
    mistifycfg=$mistifycfgdefault
  fi
fi

buildrootkernelheaders=`grep BR2_LINUX_KERNEL_VERSION $mistifycfg | cut -d \" -f 2`

message "The Buildroot config file is: $mistifycfg"
message "The kernel headers version is: $buildrootkernelheaders"

brc=$variantbuilddir/.config
if [ -f $mistifycfg ]; then
  verbose "Base config: $mistifycfg"
  verbose "Target file: $brc"
  verbose "Variant: $variant"
  use_variant $mistifycfg $brc $variant
  if [ $? -gt 0 ]; then
    error "Could not copy the Buildroot config file."
    exit 1
  fi
  message "Config file $mistifycfg copied to $brc"
  echo $mistifycfg >$statedir/config
else
  case "$target" in
    "menuconfig" | "nconfig")
      ;;
    *)
      error "The config file doesn't exist. Run $0 menuconfig."
      exit 1
      ;;
  esac
fi

#+
# Setup the correct kernel config file.
# TODO: Add a check to verify the kernel config file exists.
#
if [ -z "$kernelcfg" ]; then
  if [ -f $statedir/kconfig ]; then
    kernelcfg=`cat $statedir/kconfig`
  else
    kernelcfg=$kernelcfgdefault
  fi
fi
message "The Buildroot kernel config file is: $kernelcfg"

brkc=$variantbuilddir/build/linux-`grep BR2_LINUX_KERNEL_VERSION $brc | cut -d "\"" -f 2`/.config
verbose "Kernel configuration file: $brkc"
if [ -f $brkc ]; then
  if [ -f $kernelcfg ]; then
    use_variant $kernelcfg $brkc $variant
    if [ $? -gt 0 ]; then
      error "Could not copy the kernel config file."
      exit 1
    fi
    message "Config file $kernelcfg copied to $brkc"
    echo $kernelcfg >$statedir/kconfig
  else
    if [[ "$target" != "linux-menuconfig" ]]; then
      error "The kernel config file doesn't exist. Run ./buildmistify linux-menuconfig."
      exit 1
    fi
  fi
fi

#+
# Setup the correct busybox config file.
#
if [ -z "$busyboxcfg" ]; then
  if [ -f $statedir/bbconfig ]; then
    busyboxcfg=`cat $statedir/bbconfig`
  else
    busyboxcfg=$busyboxcfgdefault
  fi
fi
message "The Buildroot BusyBox config file is: $busyboxcfg"

bbc=`ls -d $variantbuilddir/build/busybox-*`/.config

if [ -f $bbc ]; then
  if [ -f $busyboxcfg ]; then
    if [[ $busyboxcfg -nt $bbc ]]; then
      use_variant $busyboxcfg $bbc $variant
      if [ $? -gt 0 ]; then
        warning "Busybox hasn't been built yet."
      fi
      message "Config file $busyboxcfg copied to $bbc"
      echo $busyboxcfg >$statedir/bbconfig
    fi
  else
    if [[ "$target" != "busybox-menuconfig" ]]; then
      error "The BusyBox config file doesn't exist."
      message "Run ./buildmistify busybox-menuconfig."
      exit 1
    fi
  fi
fi

#+
# Setup the downloads directory.
#-
if [ -z "$downloaddir" ]; then
  if [ -f $statedir/downloaddir ]; then
    downloaddir=`cat $statedir/downloaddir`
  else
    downloaddir=$downloaddirdefault
  fi
fi
echo $downloaddir >$statedir/downloaddir

message "The Buildroot download directory is: $downloaddir"

#+
# Some packages may be configured to always pull from the head of a master
# branch. This results in cached download files matching the pattern *master*.
# Because of this stale verisions could actually be used because buildroot
# uses the version in the name to indicate whether the cached file exists
# or not. In the case of using "master" the version doesn't change so Buildroot
# will be mislead into thinking the cached file is current when in fact it's not.
# So, remove such files to force a fresh pull.
#-
if [ -n "$resetmasters" ]; then
  if [ -d $downloaddir ]; then
    p=$downloaddir/*-master.tar*
    if ls $p 1> /dev/null 2>&1; then
      for f in `ls $p`; do
        warning "Removing cached master branch file: $f"
        rm $f
      done
    fi
  fi
fi


message "Project dir: $projectdir"

#+
# Be sure the toolchain is installed.
#-
install-toolchain
if [[ $? -gt 0 ]]; then
    #+
    # If the toolchain was built then a full rebuild is needed.
    #-
    warning "The toolchain has changed. A full target rebuild is recommended."
    warning "Run ./buildmistify clean and then ./buildmistify to rebuild."
    exit
fi
install-go

#+
# Now run the build.
#-
export MISTIFY_DIR=$projectdir
makecommand="\
make O=$variantbuilddir \
TOOLCHAIN_PATH=$TC_PREFIX_DIR TOOLCHAIN_PREFIX=$toolchainprefix \
BR2_CCACHE_DIR=$builddir/.buildroot_ccache \
BR2_DL_DIR=$downloaddir BR2_EXTERNAL=$projectdir \
BR2_DEFAULT_KERNEL_HEADERS=$buildrootkernelheaders \
GOROOT=$GOROOT -C $buildrootdir \
$target"

#+
# Don't run the build if changing configurations.
#-
case "$target" in
    "menuconfig" | "nconfig")
	touch $timestampfile
	verbose "Current directory is: $PWD"
	$makecommand
	if [[ ! -f $mistifycfg || $brc -nt $timestampfile ]]; then
	    #+
	    # NOTE: The buildroot config option BR2_DEFCONFIG
	    # needs to point to the config file so that buildroot will copy the correct
	    # file on the first build.
	    #-
	   update_variant $brc $mistifycfg $variant
	    if [ $? -gt 0 ]; then
		error "Failed to save $mistifycfg"
		exit 1
	    fi
	    tip "Use $0 to build Mistify using the new configuration."
	    if [ -z "$variant" ]; then
		message "New config file at $brc saved to $mistifycfg"
	    else
		message "The configuration variant saved to $variant"
	    fi
	fi
	rm -f $timestampfile
	exit
	;;
    "xconfig" | "gconfig")
	error "Configuration tool $target is not supported."
	exit 1
	;;
    "linux-menuconfig")
	#+
	# NOTE: The buildroot config option BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE
	# needs to point to the config file so that buildroot will copy the correct
	# file on the first build.
	#-
	touch $timestampfile
	$makecommand
	if [[ ! -f $kernelcfg || $brkc -nt $timestampfile ]]; then
	    update_variant $brkc $kernelcfg $variant
	    if [ $? -gt 0 ]; then
		error "Failed to save $kernelcfg"
		exit 1
	    fi
	    tip "Use $0 to build Mistify using the new configuration."
	    if [ -z "$variant" ]; then
		message "New kernel config file at $brkc saved to $kernelcfg"
	    else
		message "The kernel configuration variant saved to $variant"
	    fi
	fi
	rm -f $timestampfile
	exit
	;;
    "busybox-menuconfig")
	#+
	# NOTE: The buildroot config option BR2_PACKAGE_BUSYBOX_CONFIG
	# needs to point to the config file so that buildroot will copy the correct
	# file on the first build.
	#-
	touch $timestampfile
	$makecommand
	# NOTE: May want to use grep instead of a timestamp compare.
	if [[ ! -f $busyboxcfg || $bbc -nt $timestampfile ]]; then
	    update_variant $bbc $busyboxcfg $variant
	    if [ $? -gt 0 ]; then
		error "Failed to save $busyboxcfg"
		exit 1
	    fi
	    tip "Use $0 to build Mistify using the new configuration."
	    if [ -z "$variant" ]; then
		message "New BusyBox config file $bbc saved to $busyboxcfg"
	    else
		message "The BusyBox configuration variant saved to $variant"
	    fi
	fi
	rm -f $timestampfile
	exit
	;;
    *)
	;;
esac

#+
# Setup the build log file.
#-
if [ -z "$logfilename" ]; then
  logfilename=buildroot-`date +%y%m%d%H%M%S`.log
fi
logfile=$logdir/$logfilename

message "Logging the build output to: $logfile"

#+
# Run buildroot.
#-
if [ -n "$dryrun" ]; then
  message "Just a dry run -- not running make."
  verbose $makecommand
else
  #+
  # Run the buildroot make.
  #-
  time $makecommand 2>&1 | tee $logfile
  rc=${PIPESTATUS[0]}
  message "The Mistify-OS build is complete."
  message "The log file is: $logfile"
  if [ $rc -gt 0 ]; then
    error "Make complained about a build problem (see $logfile)."
    if [ -n "$viewlog" ]; then
      less $logfile
    fi
    exit 1
  fi
fi

#+
# Prepare the "official" images and generate corresponding sha1s.
# WARNING: This requires the corresponding images be enabled in the Buildroot
# configuration file ($mistifycfg).
#-
imagedir=$variantbuilddir/images
cd $imagedir
if [ -f rootfs.cpio.gz ]; then
  ln -sf rootfs.cpio.gz initrd.mistify
  sha1sum initrd.mistify >initrd.mistify.sha1
else
  warning "The initrd doesn't exist."
fi
if [ -f bzImage ]; then
  ln -sf bzImage bzImage.mistify
  sha1sum bzImage.mistify >bzImage.mistify.sha1
else
  warning "The kernel image doesn't exist."
fi
if [ -f rootfs.iso9660 ]; then
  ln -sf rootfs.iso9660 mistify.iso
  sha1sum mistify.iso >mistify.iso.sha1
else
  warning "The ISO image doesn't exist."
fi
cd -

ln -sf $logfilename $logdir/buildroot.Log

message "Images are in $imagedir and can be uploaded to the server."
message "bzImage.buildroot: The kernel image."
message "initrd.buildroot: The RAM disk."
if [ -e $imagedir ]; then
  ls -l $imagedir
fi

